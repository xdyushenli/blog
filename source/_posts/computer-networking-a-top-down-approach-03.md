---
title: 计算机网络：自顶向下方法读书笔记（三）
date: 2019-12-18 10:05:24
tags: [ 计算机网络 ]
---
本章详细介绍了运输层相关的知识, 从 TCP 和 UDP 运输层协议入手, 主要探讨如下两个问题：
* 两个实体如何在一种会丢失或损坏数据的媒体上进行可靠通信?
* 如何控制运输层实体的传输速率以避免网络拥塞, 以及如何从拥塞中恢复过来?

# 概述
## 运输层的层级
运输层介于应用层之下, 网络层之上。
## 运输层提供的功能
运输层协议为运行在不同主机上的应用进程之间提供了`逻辑通信`功能。所谓`逻辑通信`, 是指应用进程通过运输层提供的功能进行通信, 而无需关心承载这些报文的物理基础设施细节。
## 运输层实现的位置
运输层协议是在端系统中而非路由器中实现的。
## 运输层与网络层的区别
网络层提供了主机之间的逻辑通信, 运输层提供了运行在不同主机上的应用进程之间的逻辑通信。
## 运输层分组的名称
运输层的分组称为`报文段（segment）`。

# 多路复用与多路分解
在之前的内容中我们了解到, 在接收主机中的运输层实际上并没有直接把数据交付给进程, 而是将数据交给了一个中间套接字。每个套接字都有唯一标识符用于与其他套接字做区分。对应的, 每个运输层报文段中都会有几个字段, 用于唯一标识套接字。在接收端, 运输层检查这些字段, 标识出接收套接字, 进而将报文段定向到该套接字。
将运输层报文段中的数据交付到正确的套接字的工作称为`多路分解（demultiplexing）`。
在源主机从不同套接字中收集数据块,并未每个数据块封装上首部信息（用于以后分解）从而生成报文段, 然后将报文段传递到网络层, 所有这些工作称为`多路复用（multiplexing）`。

## 多路复用与多路分解的报文结构
要实现多路复用和多路分解, 要同时满足两个要求：
1. 套接字有唯一标识符。
2. 报文中有特殊字段将报文导向某个套接字。 
这些特殊的字段便是`源端口号字段（source port number field）`以及`目的端口号字段（destination port number field）`, TCP报文段 和 UDP 报文段中还有其他一些字段。
端口号是一个 16 位比特的数, 其大小在 0 ~ 65535 之间, 其中 0 ~ 1023 为`周知端口号（well-know port number）`, 专门为一些诸如 HTTP 等的协议保留。如果应用程序开发者编写的是一个`周知协议`的服务器端, 那么开发者必须为其分配一个相应的周知端口号。通常, 应用程序的客户端让运输层自动地（并且是透明地）分配端口号, 而服务器端则分配一个特定的端口号。

## 无连接的多路复用和多路分解
最常见的无连接多路复用和多路分解便是 UDP。
一个 UDP 套接字是由一个二元组唯一标识的, 该二元组包含一个`目的 IP 地址`和一个`目的端口号`。

## 有连接的多路复用和多路分解
最常见的有连接的多路复用和多路分解便是 TCP。
一个 TCP 套接字是由一个四元组唯一标识的, 该四元组包括一个`源 IP 地址`、一个`源端口号`、一个`目的 IP 地址`以及一个`目的端口号`。
尤其与 UDP 不同的是, 两个具有不同源 IP 地址或两个具有不同源端口号的 TCP 报文段会被定向到两个不同的套接字（即`连接套接字`）, 除非 TCP 报文段携带了初始的创建连接的请求, 它们会被定向到同一个套接字（即`欢迎套接字`）。

# 无连接运输：UDP
**运输层最低限度必须提供一种复用/分解服务, 以便在网络层与正确的应用层进程之间传递数据。**
由 [RFC768](https://tools.ietf.org/html/rfc768) 定义的 UDP 只是做了运输层协议能够做到最少工作。除了复用/分解服务以及差错检测外, 它几乎没有对 IP 协议增加任何东西。因此 UDP 并不如 TCP 那么可靠, 属于`尽力而为型的协议`。

## 为什么要使用 UDP?
与 TCP 相比, UDP 具有如下几种优势让人：
1. **对发送什么数据以及何时发送的应用层控制更为精细。**采用 UDP 时, 只要进程把数据传入 UDP, UDP 便会立刻将此数据打包进 UDP 报文段并发送。而采用 TCP 时, 由于其拥塞控制机制的存在, 因此常常会遏制发送速率。对于一些要求最小发送速率, 且能容忍一部分数据丢失的应用而言, UDP 显然要比 TCP 要好。
2. **无需建立连接。**
3. **无连接状态。**TCP 需要在端系统中维护连接状态, 包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数。而 UDP 无需维护连接状态, 因此也无需跟踪这些参数。一般来说, 服务器中某个特定功能的应用程序运行在 UDP 上而不是 TCP 上时, 能支持更多的用户。
4. **分组首部开销小。**每个 TCP 报文段都有 20 个字节的首部开销, 而 UDP 仅有 8 个字节的首部开销。

## UDP 报文段结构
UDP 报文段由两大部分组成, 一部分是`数据字段`：由应用数据报文占据; 另一部分是`首部字段`, 共有 4 个, 每个两字节（16 比特）, 共 8 字节, 分别是：
* `源端口号`：发送主机中 UDP 报文段的源套接字所对应的端口号。
* `目的端口号`：接收主机中 UDP 报文段的目的套接字所对应的端口号。
* `长度`：指示 UDP 报文段中的字节数（首部加数据）, 不固定。
* `校验和`：接收方通过检验和来检测该报文段中是否出现了差错。计算方法是对报文段中的所有 16 比特的字进行不进位加法, 之后对得到的数字进行反码计算。在接收方, 全部报文段中的 16 比特的字相加（包括校验和）, 结果应该是 1111 1111 1111 1111。如果这些比特之一为 0, 那么肯定就出现了差错。

![UDP报文结构](/images/computer-networking-a-top-down-approach-03/01.png)

值得注意的是, 虽然 UDP 提供差错检测, 但对差错恢复无能为力。
UDP 虽然是不可靠传输协议, 但是基于 UDP 的应用程序是可以实现可靠传输的, 这可通过在应用程序（应用层）中建立可靠性机制来完成。 

# 可靠数据传输原理
实现可靠数据传输的协议称为`可靠数据传输协议（reliable data transfer protocol）`。由于现实中可靠数据传输协议的下层协议也许是不可靠的, 因此实现可靠传输是一项十分困难的任务。

## 构造可靠数据传输协议
我们将从完全可靠信道开始, 逐步降低信道的可靠度以贴近实际, 来探讨如何建立可靠数据传输。
在这里有一个贯穿整个讨论的假设, 那就是：***底层信道不会对分组重排序, 分组将以它们发送的次序进行交付。无论是接收方还是发送方, 每次都只接收/发送一个分组。***

### 经过完全可靠信道的可靠数据传输：rdt1.0
rdt1.0 的`有限状态机（Finite-State Machine, FSM）`定义如图所示。
`FSM 描述图`使用虚线表示初始状态, 箭头表示状态迁移, 引起变迁的事件显示在表示变迁的横线上方, 事件发生时采取的动作表示在横线下方。

![rdt1.0](/images/computer-networking-a-top-down-approach-03/02.png)

由于信道是完全可靠的, 因此接收方并不需要提供任何反馈信息给发送方。且我们假定***接收方接收数据的速率与发送方发送数据的速率一样快,*** 因此接收方并不需要请求发送方降低发送速度。

### 经过具有比特差错信道的可靠数据传输：rdt2.0
一种更为贴近实际的底层信道模型是***分组中的比特可能受损的信道模型***。在分组的传输、传播或缓存的过程中, 这种比特差错常常会出现在网络的物理部件中。
#### 自动重传请求（ABQ）协议
针对可能发生的比特差错问题, 一种解决方式是使用`肯定确认（postive acknowledgement）`报文和`否定确认（negative acknowledegment）`报文。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收, 哪些内容接收有误需要重发。基于这种重传机制的可靠数据传输协议称为`自动重传请求（Automatic Repeat reQuest, ARQ）协议`。

ARQ 协议需要三种协议功能以实现通过具有比特差错信道的可靠数据传输：
* `差错检测`：用检验和字段实现差错检测。
* `接收方反馈`：接收方将发送 `ACK 分组`与 `NAK 分组`, 为发送方提供信息。
* `重传`：接收方收到有差错的分组时, 发送方将重传该分组。

#### rdt2.0
rdt2.0 发送方和接收方的 FSM 图如下。

![rdt2.0](/images/computer-networking-a-top-down-approach-03/03.png)

注意以下事实：**当发送方处于等待 ACK 或 NAK 的状态时, 它不能从上层获取更多的数据。**只有发送方确信接收方已正确接收当前分组后, 才会发送新的分组。具有这种行为的协议被称为`停等（stop-and-wait）协议`。

#### rdt2.1
rdt2.0 看上去很不错, 但是有一个致命的缺陷, 那就是**没有考虑 ACK 或 NAK 分组受损的可能性。**
为了应对这种情况, 我们需要同时采取两种措施：
1. 为 ACK 和 NAK 分组添加检验和字段, 以此来检测分组是否损坏。
2. 在发送分组和控制分组中添加`序号（sequence number）`字段。*当发送方收到损坏的 ACK 分组或收到 NAK 分组时会重传当前的数据分组。*
rdt2.1 发送方和接收方的 FSM 图如下。

![rdt2.1](/images/computer-networking-a-top-down-approach-03/04.png)

![rdt2.1](/images/computer-networking-a-top-down-approach-03/05.png)

应当注意到, 由于 rdt2.1 是停等协议, 因此只需要 1 比特序号就够了。

#### rdt2.2
**rdt2.2 实现了与 rdt2.1 相同的效果。**不同的是, rdt2.2 是在比特差错信道上实现的**一个无 NAK 的可靠数据传输协议。**
rdt2.2 的重传条件与 rdt2.1 有所不同。*当收到冗余 ACK 或损坏的 ACK 包时, 发送方会重传当前分组。*
rdt2.2 发送方和接收方的 FSM 图如下。

![rdt2.2](/images/computer-networking-a-top-down-approach-03/06.png)

![rdt2.2](/images/computer-networking-a-top-down-approach-03/07.png)

### 经过具有比特差错的丢包信道的可靠数据传输：rdt3.0
***在实际中, 底层信道不仅会发生比特差错, 还可能会发生丢包。***因此在 rdt2.2 的基础上, rdt3.0 需要关注另外两个问题：怎样检测丢包以及发生丢包后该做什么。
在这里, 我们把检测和恢复丢包的工作交给发送方。假定发送方传输一个数据分组, 该分组或接收方发送的 ACK 发生了丢失。在这两种情况下, 发送方都收不到应当到来的接收方的相应。如果发送方愿意等待足够长的时间（即发送方与接收方之间的一个往返时延加上接收方处理一个分组所需的时间）以确认分组已丢失, 则它只需要重传丢失分组即可。
为了实现这种重传机制, 需要一个`倒计时定时器（countdown timer）`。在实践中, 发送方会明智地选择一个时间值, 以判定可能发生了丢包。如果在这个时间内没有收到正确的 ACK, 则会重传该分组。
rdt3.0 发送方的 FSM 图如下。

![rdt3.0](/images/computer-networking-a-top-down-approach-03/08.png)

因为分组序号在 0 和 1 之间交替, 因此 rdt3.0 又称为`比特交替（alternative-bit）协议`。
我们注意到, rdt2.2 的发送方与 rdt3.0 的发送方的区别在于添加了定时器, 这会在发送方和接收方之间的信道中引入了`冗余数据分组（duplicate data packet）`。而 rdt2.2 的接收方已经能处理冗余数据分组, 因此**rdt2.2 中的接收方也能充当 rdt3.0 中的接收方。**
至此, 通过引入检验和、肯定确认、否定确认、序号和定时器, 我们得到了一个可靠数据传输协议！

## 流水线可靠数据传输协议
rdt3.0 是一个功能正确的协议, 但其性能却差强人意。**影响 rdt3.0 性能的核心问题在于它是一个停等协议。**停等协议一次只能发送一个分组, 并且只有在收到 ACK 后才会发送下一个分组, 而将分组送入信道的时间只占整个发送时间的一小部分（大部分是 RTT）, 因此停等协议发送方的信道在大部分时间都是空闲状态, 不发送也不接收任何数据, 这对性能是一种极大的浪费！
这种性能问题有一个简单的解决方法, 那就是：**不以停等方式运行, 允许发送方发送多个分组而无需等待确认。**由于从发送方看来, 这种发送方式可以看做是将分组填充到一条流水线中, 因此这种技术被称为`流水线（pipelining）`。

![停等和流水线的发送](/images/computer-networking-a-top-down-approach-03/08.png)

流水线技术会对可靠数据传输协议带来如下影响：
1. **必须增大序号范围**。因为同时会传输多个分组, 而每个输送中的分组必须有一个唯一的序号。
2. **协议的发送方和接收方两端需缓存多个分组。**发送方最低限度应该能缓存还未发送的分组, 接收方需要能够缓存已正确接收的分组。

**所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏或延时过大的分组。**解决流水线差错恢复有两种基本方法, 分别是：`回退 N 步（Go-Back-N, GBN）`和`选择重传（Selective Repeat, SR）`。

### 回退 N 步
### 选择重传

# 面向连接的运输：TCP

# 拥塞控制原理
todo 注意接收、收到的正确使用, 全文搜索接受和受到并替换
